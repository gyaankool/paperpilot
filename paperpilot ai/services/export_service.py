import os
import logging
from typing import Dict, Any
from datetime import datetime
from config.settings import Config

logger = logging.getLogger(__name__)

class ExportService:
    """Service for exporting papers and generating metadata"""
    
    def __init__(self):
        """Initialize export service"""
        self.export_folder = Config.EXPORT_FOLDER
        self.supported_formats = Config.SUPPORTED_EXPORT_FORMATS
        
        # Create export directory if it doesn't exist
        os.makedirs(self.export_folder, exist_ok=True)
    
    def export_paper(self, content: str, format_type: str, filename: str) -> str:
        """Export paper in specified format"""
        try:
            if format_type not in self.supported_formats:
                raise ValueError(f"Unsupported format: {format_type}")
            
            # Generate file path
            file_path = os.path.join(self.export_folder, f"{filename}.{format_type}")
            
            if format_type == 'txt':
                self._export_as_txt(content, file_path)
            elif format_type == 'html':
                self._export_as_html(content, file_path)
            elif format_type == 'tex':
                self._export_as_tex(content, file_path)
            elif format_type == 'pdf':
                self._export_as_pdf(content, file_path)
            elif format_type == 'docx':
                self._export_as_docx(content, file_path)
            else:
                raise ValueError(f"Export format {format_type} not implemented")
            
            return file_path
            
        except Exception as e:
            logger.error(f"Error exporting paper: {str(e)}")
            raise
    
    def _export_as_txt(self, content: str, file_path: str):
        """Export as plain text"""
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(content)
    
    def _export_as_html(self, content: str, file_path: str):
        """Export as HTML"""
        html_content = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>Research Paper</title>
            <style>
                body {{
                    font-family: 'Times New Roman', serif;
                    line-height: 1.6;
                    max-width: 800px;
                    margin: 0 auto;
                    padding: 20px;
                }}
                h1, h2, h3 {{
                    color: #333;
                }}
                .abstract {{
                    background-color: #f5f5f5;
                    padding: 15px;
                    border-left: 4px solid #007acc;
                    margin: 20px 0;
                }}
                .references {{
                    margin-top: 30px;
                }}
            </style>
        </head>
        <body>
            <div class="content">
                {self._format_content_as_html(content)}
            </div>
        </body>
        </html>
        """
        
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(html_content)
    
    def _export_as_tex(self, content: str, file_path: str):
        """Export as LaTeX"""
        latex_content = f"""
        \\documentclass{{article}}
        \\usepackage[utf8]{{inputenc}}
        \\usepackage{{amsmath}}
        \\usepackage{{amsfonts}}
        \\usepackage{{amssymb}}
        \\usepackage{{graphicx}}
        \\usepackage{{hyperref}}
        
        \\title{{Research Paper}}
        \\author{{Generated by PaperPilot}}
        \\date{{\\today}}
        
        \\begin{{document}}
        
        \\maketitle
        
        {self._format_content_as_latex(content)}
        
        \\end{{document}}
        """
        
        with open(file_path, 'w', encoding='utf-8') as file:
            file.write(latex_content)
    
    def _export_as_pdf(self, content: str, file_path: str):
        """Export as PDF with getskilled watermark"""
        try:
            # Try to use reportlab for PDF generation
            from reportlab.lib.pagesizes import letter
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer
            from reportlab.lib.styles import getSampleStyleSheet
            from reportlab.lib.colors import lightgrey
            from reportlab.pdfgen import canvas
            from reportlab.lib.units import inch
            import io
            
            # Create a buffer for the PDF content
            buffer = io.BytesIO()
            
            # Create PDF document
            doc = SimpleDocTemplate(buffer, pagesize=letter)
            styles = getSampleStyleSheet()
            story = []
            
            # Split content into paragraphs
            paragraphs = content.split('\n\n')
            
            for para in paragraphs:
                if para.strip():
                    p = Paragraph(para.strip(), styles['Normal'])
                    story.append(p)
                    story.append(Spacer(1, 12))
            
            # Build the document
            doc.build(story)
            
            # Get the PDF content
            pdf_content = buffer.getvalue()
            buffer.close()
            
            # Add watermark to the PDF
            self._add_pdf_watermark(pdf_content, file_path)
            
        except ImportError:
            logger.warning("reportlab not installed, creating text file instead")
            # Fallback to text file
            txt_path = file_path.replace('.pdf', '.txt')
            self._export_as_txt(content, txt_path)
            raise ValueError("PDF export requires reportlab library")
    
    def _export_as_docx(self, content: str, file_path: str):
        """Export as DOCX with getskilled watermark"""
        try:
            from docx import Document
            from docx.shared import Inches
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            from docx.oxml.shared import OxmlElement, qn
            
            doc = Document()
            
            # Add getskilled watermark to the document
            self._add_docx_watermark(doc)
            
            # Add title
            doc.add_heading('Research Paper', 0)
            
            # Split content into paragraphs
            paragraphs = content.split('\n\n')
            
            for para in paragraphs:
                if para.strip():
                    doc.add_paragraph(para.strip())
            
            doc.save(file_path)
            
        except ImportError:
            logger.warning("python-docx not installed, creating text file instead")
            # Fallback to text file
            txt_path = file_path.replace('.docx', '.txt')
            self._export_as_txt(content, txt_path)
            raise ValueError("DOCX export requires python-docx library")
    
    def _format_content_as_html(self, content: str) -> str:
        """Format content for HTML export"""
        # Basic HTML formatting
        html_content = content.replace('\n', '<br>')
        
        # Add basic structure
        if 'Abstract' in content:
            html_content = html_content.replace('Abstract', '<h2>Abstract</h2>')
        if 'Introduction' in content:
            html_content = html_content.replace('Introduction', '<h2>Introduction</h2>')
        if 'Conclusion' in content:
            html_content = html_content.replace('Conclusion', '<h2>Conclusion</h2>')
        if 'References' in content:
            html_content = html_content.replace('References', '<h2>References</h2>')
        
        return html_content
    
    def _format_content_as_latex(self, content: str) -> str:
        """Format content for LaTeX export"""
        # Basic LaTeX formatting
        latex_content = content
        
        # Add section commands
        if 'Abstract' in content:
            latex_content = latex_content.replace('Abstract', '\\section*{Abstract}')
        if 'Introduction' in content:
            latex_content = latex_content.replace('Introduction', '\\section{Introduction}')
        if 'Conclusion' in content:
            latex_content = latex_content.replace('Conclusion', '\\section{Conclusion}')
        if 'References' in content:
            latex_content = latex_content.replace('References', '\\section{References}')
        
        return latex_content
    
    def generate_submission_metadata(self, paper_data: Dict[str, Any]) -> Dict[str, Any]:
        """Generate submission metadata package"""
        try:
            metadata = {
                'submission_info': {
                    'title': paper_data.get('title', 'Research Paper'),
                    'authors': paper_data.get('authors', []),
                    'abstract': paper_data.get('abstract', ''),
                    'keywords': paper_data.get('keywords', []),
                    'subject_classification': paper_data.get('subject_classification', ''),
                    'funding_info': paper_data.get('funding_info', ''),
                    'conflicts_of_interest': paper_data.get('conflicts_of_interest', 'None declared'),
                    'data_availability': paper_data.get('data_availability', 'Available upon request'),
                    'ethics_approval': paper_data.get('ethics_approval', 'Not applicable'),
                    'submission_date': datetime.utcnow().isoformat()
                },
                'technical_info': {
                    'word_count': paper_data.get('word_count', 0),
                    'page_count': paper_data.get('page_count', 0),
                    'figure_count': paper_data.get('figure_count', 0),
                    'table_count': paper_data.get('table_count', 0),
                    'reference_count': paper_data.get('reference_count', 0),
                    'file_formats': paper_data.get('file_formats', ['PDF']),
                    'software_used': paper_data.get('software_used', [])
                },
                'journal_info': {
                    'target_journal': paper_data.get('target_journal', ''),
                    'journal_guidelines': paper_data.get('journal_guidelines', ''),
                    'citation_style': paper_data.get('citation_style', 'APA'),
                    'format_requirements': paper_data.get('format_requirements', {})
                },
                'generated_at': datetime.utcnow().isoformat(),
                'generated_by': 'PaperPilot AI'
            }
            
            return metadata
            
        except Exception as e:
            logger.error(f"Error generating submission metadata: {str(e)}")
            raise
    
    def get_mimetype(self, format_type: str) -> str:
        """Get MIME type for file format"""
        mimetypes = {
            'pdf': 'application/pdf',
            'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
            'tex': 'application/x-tex',
            'html': 'text/html',
            'txt': 'text/plain'
        }
        
        return mimetypes.get(format_type, 'application/octet-stream')
    
    def cleanup_old_exports(self, max_age_hours: int = 24):
        """Clean up old export files"""
        try:
            import time
            
            current_time = time.time()
            max_age_seconds = max_age_hours * 3600
            
            for filename in os.listdir(self.export_folder):
                file_path = os.path.join(self.export_folder, filename)
                
                if os.path.isfile(file_path):
                    file_age = current_time - os.path.getmtime(file_path)
                    
                    if file_age > max_age_seconds:
                        os.remove(file_path)
                        logger.info(f"Cleaned up export file: {filename}")
                        
        except Exception as e:
            logger.error(f"Error cleaning up export files: {str(e)}")
    
    def get_export_summary(self, file_path: str) -> Dict[str, Any]:
        """Get summary of exported file"""
        try:
            if not os.path.exists(file_path):
                return {'error': 'File not found'}
            
            file_size = os.path.getsize(file_path)
            file_extension = file_path.split('.')[-1].lower()
            
            return {
                'file_path': file_path,
                'file_size': file_size,
                'file_extension': file_extension,
                'exported_at': datetime.fromtimestamp(os.path.getmtime(file_path)).isoformat(),
                'download_ready': True
            }
            
        except Exception as e:
            logger.error(f"Error getting export summary: {str(e)}")
            return {
                'error': str(e),
                'download_ready': False
            }
    
    def _add_pdf_watermark(self, pdf_content: bytes, file_path: str):
        """Add getskilled watermark to PDF"""
        try:
            from reportlab.pdfgen import canvas
            from reportlab.lib.pagesizes import letter
            from reportlab.lib.colors import lightgrey
            from reportlab.lib.units import inch
            from PyPDF2 import PdfReader, PdfWriter
            import io
            
            # Create watermark
            watermark_buffer = io.BytesIO()
            c = canvas.Canvas(watermark_buffer, pagesize=letter)
            
            # Set watermark properties
            c.setFont("Helvetica-Bold", 48)
            c.setFillColor(lightgrey)
            c.setFillAlpha(0.1)  # Very transparent
            
            # Rotate and position watermark
            c.saveState()
            c.rotate(45)  # Diagonal watermark
            c.drawString(200, 200, "getskilled")
            c.restoreState()
            
            c.save()
            watermark_pdf = watermark_buffer.getvalue()
            watermark_buffer.close()
            
            # Merge watermark with original PDF
            original_reader = PdfReader(io.BytesIO(pdf_content))
            watermark_reader = PdfReader(io.BytesIO(watermark_pdf))
            writer = PdfWriter()
            
            # Add watermark to each page
            for page_num in range(len(original_reader.pages)):
                page = original_reader.pages[page_num]
                watermark_page = watermark_reader.pages[0]
                page.merge_page(watermark_page)
                writer.add_page(page)
            
            # Write final PDF
            with open(file_path, 'wb') as output_file:
                writer.write(output_file)
                
        except Exception as e:
            logger.error(f"Error adding PDF watermark: {str(e)}")
            # Fallback: save without watermark
            with open(file_path, 'wb') as f:
                f.write(pdf_content)
    
    def _add_docx_watermark(self, doc):
        """Add getskilled watermark to DOCX document"""
        try:
            from docx.oxml.shared import OxmlElement, qn
            from docx.oxml.ns import nsdecls
            from docx.oxml import parse_xml
            from docx.shared import Inches
            from docx.enum.text import WD_ALIGN_PARAGRAPH
            
            # Create watermark element
            watermark_xml = '''
            <w:watermark xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
                <w:watermark type="text" color="lightgray" opacity="0.1">
                    <w:text>getskilled</w:text>
                </w:watermark>
            </w:watermark>
            '''
            
            # Add watermark to document background
            try:
                # Add a hidden paragraph with watermark text
                watermark_para = doc.add_paragraph()
                watermark_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                
                # Style the watermark text
                run = watermark_para.runs[0] if watermark_para.runs else watermark_para.add_run("getskilled")
                run.font.size = Inches(0.5)
                run.font.color.rgb = None  # Use default color
                
                # Make it very light and positioned
                watermark_para.paragraph_format.space_after = Inches(0)
                watermark_para.paragraph_format.space_before = Inches(0)
                
                # Alternative: Add watermark as header/footer
                section = doc.sections[0]
                header = section.header
                header_para = header.paragraphs[0]
                header_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                header_run = header_para.add_run("getskilled")
                header_run.font.size = Inches(0.3)
                header_run.font.color.rgb = None
                
            except Exception as e:
                logger.warning(f"Could not add advanced watermark: {str(e)}")
                # Fallback: simple watermark
                watermark_para = doc.add_paragraph()
                watermark_para.alignment = WD_ALIGN_PARAGRAPH.CENTER
                run = watermark_para.add_run("getskilled")
                run.font.size = Inches(0.4)
                
        except Exception as e:
            logger.error(f"Error adding DOCX watermark: {str(e)}")
            # Continue without watermark if there's an error
